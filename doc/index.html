<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>Side by side: Datomic and PostgreSQL, Part 1</title>
	</head>
<body>
<h1>Side by side: Datomic and PostgreSQL, Part 1</h1>

<p>Greetings fellow Cojurians, to clarify from the outset, the objective of this article (or series of articles) is to highlight the differences in data modeling between SQL and Datomic. The conclusion will be yours to draw; I will merely present the facts.</p>

<p>Datomic was once considered a luxury product in the realm of parentheses, causing many companies and projects to avoid it. Eventually, NuBank decided to acquire Cognitect. Perhaps it was cheaper to buy the company than to continue paying licensing fees in the long term. A few months later, Datomic was released as a free-to-use product. </p>

<p>What makes Datomic special? In my experience, it&#39;s an entirely different type of database compared to what I, and possibly you, have used in production before. It&#39;s a refreshing change in terms of developer experience and code organization. One particular feature that may seem alien to those in the SQL world is Datomic&#39;s time-oriented design. </p>

<p>What does it mean to be time-oriented? In Datomic, the database does not only contain the current state of the data, but it also retains a complete history of changes made to that data. In other words, Datomic stores not only the present state but also past states of the data. However, before we delve into this, we will take a thorough tour of Datomic and SQL, comparing these two paradigms.</p>

<p>While there&#39;s much to discuss, I prefer to demonstrate through examples. The context will be simple data modeling and execution to provide examples of both approaches, enabling readers to draw their own conclusions.</p>

<p>— </p>

<h2>ERD</h2>

<p>To kick off our exploration, let’s define a simple <em>E</em>ntity <em>R</em>elationship <em>M</em>odel:</p>

<figure><img src="ERD.png"/></figure>

<p>The path ahead of us is straightforward; it&#39;s a diagram illustrating ERD in an SQL database. Our SQL choice is the well-known Postgres. Within the Clojure ecosystem, we have a number of libraries that deal with SQL, such as HugSQL, HoneySQL, and plain SQL migration scripts. When dealing with database migration, my personal preference is the combination of plain <code>SQL</code> and <code>migratus</code>, a pair endorsed by our dear friend, exceptional individual, and veteran of Clojure open-source software - Sean Corfield, the author of our beloved HoneySQL.</p>

<h2>Schema </h2>

<h3>SQL</h3>

<pre><code class="code-highlighted code-sql"><span class="syntax-all syntax-keyword">CREATE</span> <span class="syntax-all syntax-keyword">TABLE</span> <span class="syntax-all syntax-entity">Book</span> (
    id <span class="syntax-all syntax-keyword">SERIAL</span> <span class="syntax-all syntax-keyword">PRIMARY KEY</span>,
    Title <span class="syntax-all syntax-keyword">TEXT</span> <span class="syntax-all syntax-keyword">NOT NULL</span>,
    Author <span class="syntax-all syntax-keyword">TEXT</span> <span class="syntax-all syntax-keyword">NOT NULL</span>,
    Genre <span class="syntax-all syntax-keyword">TEXT</span>,
    Publication_Date <span class="syntax-all syntax-keyword">DATE</span>
);
<span class="syntax-all syntax-comment">--;;
</span><span class="syntax-all syntax-keyword">CREATE</span> <span class="syntax-all syntax-keyword">TABLE</span> <span class="syntax-all syntax-entity">Person</span> (
    id <span class="syntax-all syntax-keyword">SERIAL</span> <span class="syntax-all syntax-keyword">PRIMARY KEY</span>,
    First_Name <span class="syntax-all syntax-keyword">TEXT</span> <span class="syntax-all syntax-keyword">NOT NULL</span>,
    Last_Name <span class="syntax-all syntax-keyword">TEXT</span> <span class="syntax-all syntax-keyword">NOT NULL</span>,
    Email <span class="syntax-all syntax-keyword">TEXT</span>
);
<span class="syntax-all syntax-comment">--;;
</span><span class="syntax-all syntax-keyword">CREATE</span> <span class="syntax-all syntax-keyword">TABLE</span> <span class="syntax-all syntax-entity">Registry</span> (
    id <span class="syntax-all syntax-keyword">SERIAL</span> <span class="syntax-all syntax-keyword">PRIMARY KEY</span>,
    Book_ID <span class="syntax-all syntax-keyword">INT</span>,
    Patron_ID <span class="syntax-all syntax-keyword">INT</span>,
    Borrower_ID <span class="syntax-all syntax-keyword">INT</span>,
    Borrow_Date <span class="syntax-all syntax-keyword">DATE</span>,
    Due_Date <span class="syntax-all syntax-keyword">DATE</span>,
    <span class="syntax-all syntax-keyword">FOREIGN KEY</span> (Book_ID) <span class="syntax-all syntax-keyword">REFERENCES</span> Book(id),
    <span class="syntax-all syntax-keyword">FOREIGN KEY</span> (Patron_ID) <span class="syntax-all syntax-keyword">REFERENCES</span> Person(id),
    <span class="syntax-all syntax-keyword">FOREIGN KEY</span> (Borrower_ID) <span class="syntax-all syntax-keyword">REFERENCES</span> Person(id),
);</code></pre>

<p><code>--;;</code> is <code>Migratus</code> specific comment to distinguish between SQL statements.</p>

<h3>Datomic</h3>

<pre><code class="code-highlighted code-clojure"><span class="syntax-all syntax-comment">;; Book</span>
 {<span class="syntax-all syntax-constant">:db/ident</span>       <span class="syntax-all syntax-constant">:book/title</span>
  <span class="syntax-all syntax-constant">:db/valueType</span>   <span class="syntax-all syntax-constant">:db.type/string</span>
  <span class="syntax-all syntax-constant">:db/cardinality</span> <span class="syntax-all syntax-constant">:db.cardinality/one</span>
  <span class="syntax-all syntax-constant">:db/doc</span>         <span class="syntax-all syntax-string">&quot;The title of a book.&quot;</span>}

 {<span class="syntax-all syntax-constant">:db/ident</span>       <span class="syntax-all syntax-constant">:book/author</span>
  <span class="syntax-all syntax-constant">:db/valueType</span>   <span class="syntax-all syntax-constant">:db.type/string</span>
  <span class="syntax-all syntax-constant">:db/cardinality</span> <span class="syntax-all syntax-constant">:db.cardinality/one</span>
  <span class="syntax-all syntax-constant">:db/doc</span>         <span class="syntax-all syntax-string">&quot;The author of a book.&quot;</span>}

 {<span class="syntax-all syntax-constant">:db/ident</span>       <span class="syntax-all syntax-constant">:book/genre</span>
  <span class="syntax-all syntax-constant">:db/valueType</span>   <span class="syntax-all syntax-constant">:db.type/string</span>
  <span class="syntax-all syntax-constant">:db/cardinality</span> <span class="syntax-all syntax-constant">:db.cardinality/one</span>
  <span class="syntax-all syntax-constant">:db/doc</span>         <span class="syntax-all syntax-string">&quot;The genre of a book.&quot;</span>}

 {<span class="syntax-all syntax-constant">:db/ident</span>       <span class="syntax-all syntax-constant">:book/publication-date</span>
  <span class="syntax-all syntax-constant">:db/valueType</span>   <span class="syntax-all syntax-constant">:db.type/instant</span>
  <span class="syntax-all syntax-constant">:db/cardinality</span> <span class="syntax-all syntax-constant">:db.cardinality/one</span>
  <span class="syntax-all syntax-constant">:db/doc</span>         <span class="syntax-all syntax-string">&quot;The publication date of a book.&quot;</span>}

 <span class="syntax-all syntax-comment">;; Person</span>
 {<span class="syntax-all syntax-constant">:db/ident</span>       <span class="syntax-all syntax-constant">:person/first-name</span>
  <span class="syntax-all syntax-constant">:db/valueType</span>   <span class="syntax-all syntax-constant">:db.type/string</span>
  <span class="syntax-all syntax-constant">:db/cardinality</span> <span class="syntax-all syntax-constant">:db.cardinality/one</span>
  <span class="syntax-all syntax-constant">:db/doc</span>         <span class="syntax-all syntax-string">&quot;The first name of a person.&quot;</span>}

 {<span class="syntax-all syntax-constant">:db/ident</span>       <span class="syntax-all syntax-constant">:person/last-name</span>
  <span class="syntax-all syntax-constant">:db/valueType</span>   <span class="syntax-all syntax-constant">:db.type/string</span>
  <span class="syntax-all syntax-constant">:db/cardinality</span> <span class="syntax-all syntax-constant">:db.cardinality/one</span>
  <span class="syntax-all syntax-constant">:db/doc</span>         <span class="syntax-all syntax-string">&quot;The last name of a person.&quot;</span>}

 {<span class="syntax-all syntax-constant">:db/ident</span>       <span class="syntax-all syntax-constant">:person/email</span>
  <span class="syntax-all syntax-constant">:db/valueType</span>   <span class="syntax-all syntax-constant">:db.type/string</span>
  <span class="syntax-all syntax-constant">:db/cardinality</span> <span class="syntax-all syntax-constant">:db.cardinality/one</span>
  <span class="syntax-all syntax-constant">:db/doc</span>         <span class="syntax-all syntax-string">&quot;The email of a person.&quot;</span>}

 <span class="syntax-all syntax-comment">;; Registry</span>
 {<span class="syntax-all syntax-constant">:db/ident</span>       <span class="syntax-all syntax-constant">:registry/book</span>
  <span class="syntax-all syntax-constant">:db/valueType</span>   <span class="syntax-all syntax-constant">:db.type/ref</span>
  <span class="syntax-all syntax-constant">:db/cardinality</span> <span class="syntax-all syntax-constant">:db.cardinality/one</span>
  <span class="syntax-all syntax-constant">:db/doc</span>         <span class="syntax-all syntax-string">&quot;The book being borrowed.&quot;</span>}

 {<span class="syntax-all syntax-constant">:db/ident</span>       <span class="syntax-all syntax-constant">:registry/patron</span>
  <span class="syntax-all syntax-constant">:db/valueType</span>   <span class="syntax-all syntax-constant">:db.type/ref</span>
  <span class="syntax-all syntax-constant">:db/cardinality</span> <span class="syntax-all syntax-constant">:db.cardinality/one</span>
  <span class="syntax-all syntax-constant">:db/doc</span>         <span class="syntax-all syntax-string">&quot;The patron lending a book.&quot;</span>}

 {<span class="syntax-all syntax-constant">:db/ident</span>       <span class="syntax-all syntax-constant">:registry/borrower</span>
  <span class="syntax-all syntax-constant">:db/valueType</span>   <span class="syntax-all syntax-constant">:db.type/ref</span>
  <span class="syntax-all syntax-constant">:db/cardinality</span> <span class="syntax-all syntax-constant">:db.cardinality/one</span>
  <span class="syntax-all syntax-constant">:db/doc</span>         <span class="syntax-all syntax-string">&quot;The borrower of a book.&quot;</span>}

 {<span class="syntax-all syntax-constant">:db/ident</span>       <span class="syntax-all syntax-constant">:registry/borrow-date</span>
  <span class="syntax-all syntax-constant">:db/valueType</span>   <span class="syntax-all syntax-constant">:db.type/instant</span>
  <span class="syntax-all syntax-constant">:db/cardinality</span> <span class="syntax-all syntax-constant">:db.cardinality/one</span>
  <span class="syntax-all syntax-constant">:db/doc</span>         <span class="syntax-all syntax-string">&quot;Borrowed date.&quot;</span>}

 {<span class="syntax-all syntax-constant">:db/ident</span>       <span class="syntax-all syntax-constant">:registry/due-date</span>
  <span class="syntax-all syntax-constant">:db/valueType</span>   <span class="syntax-all syntax-constant">:db.type/instant</span>
  <span class="syntax-all syntax-constant">:db/cardinality</span> <span class="syntax-all syntax-constant">:db.cardinality/one</span>
  <span class="syntax-all syntax-constant">:db/doc</span>         <span class="syntax-all syntax-string">&quot;The due date for returning the book.&quot;</span>}]</code></pre>

<ul>
	<li><code>:db/ident</code>: Unique identifier for an entity, which is typically used to provide a human-readable, namespace-qualified name for an entity, and once set, it cannot be changed. Namespace in our context is <code>:book</code> and <code>title</code> is its attribute.</li>
	<li><code>:db/valueType</code>: The type of value that can be associated with an entity. For instance, it could be used to specify that an attribute must be of type <code>:db.type/string</code>, <code>:db.type/long</code>, <code>:db.type/boolean</code>, etc.

		<ul>
			<li> <code>db.type/ref</code> means it would refer to another entity, fact (<em>datum</em>)<br/>Important different compared to SQL is a lack of direct connection with any specific entity. There’s no concept of foreign key in Datomic.</li>
		</ul></li>
	<li><code>:db/cardinality</code>: Is used to specify whether an attribute of an entity can have one or multiple values. If it is set to <code>:db.cardinality/one</code>, then each entity can have at most one value for the attribute. If it is set to <code>:db.cardinality/many</code>, then each entity can have many values for the attribute.</li>
	<li><code>:db/doc</code>: Is used to store a human-readable documentation string for an entity. It&#39;s a good practice to provide documentation for all the entities and attributes in the database, to make it clear what they represent and how they should be used.</li>
</ul>

<h2>Database setup and Migrations</h2>

<p>Next step in line is to start the database and migrate schema </p>

<h3>SQL</h3>

<p>Create role and corresponding database (<em>I assume we have PostgreSQL running and console available</em>):</p>

<pre><code class="code-highlighted code-sql">CREATE ROLE booker WITH LOGIN CREATEDB PASSWORD <span class="syntax-all syntax-string">&#39;dev&#39;</span>;
<span class="syntax-all syntax-keyword">CREATE</span> <span class="syntax-all syntax-keyword">DATABASE</span> <span class="syntax-all syntax-entity">booky</span> WITH OWNER <span class="syntax-all syntax-keyword">=</span> booker;</code></pre>

<h4>Dependencies</h4>

<p>Add these dependencies to <code>deps.edn</code> under <code>:deps</code> key</p>

<pre><code class="code-highlighted code-clojure"><span class="syntax-all syntax-comment">;; migrations</span>
migratus/migratus {<span class="syntax-all syntax-constant">:mvn/version</span> <span class="syntax-all syntax-string">&quot;1.5.1&quot;</span>}
<span class="syntax-all syntax-comment">;; SQL DSL for Clojure</span>
com.github.seancorfield/honeysql {<span class="syntax-all syntax-constant">:mvn/version</span> <span class="syntax-all syntax-string">&quot;2.4.1045&quot;</span>}
<span class="syntax-all syntax-comment">;; PostgreSQL Driver</span>
org.postgresql/postgresql {<span class="syntax-all syntax-constant">:mvn/version</span> <span class="syntax-all syntax-string">&quot;42.6.0&quot;</span>}}
<span class="syntax-all syntax-comment">;; JDBC access layer</span>
com.github.seancorfield/next.jdbc {<span class="syntax-all syntax-constant">:mvn/version</span> <span class="syntax-all syntax-string">&quot;1.3.883&quot;</span>}}</code></pre>

<h4> Code </h4>

<p><code>sql.clj</code></p>

<pre><code class="code-highlighted code-clojure">(<span class="syntax-all syntax-keyword">ns</span> <span class="syntax-all syntax-entity">gig.sql</span>
  (<span class="syntax-all syntax-constant">:require</span> [migratus.core <span class="syntax-all syntax-constant">:as</span> migratus]))

<span class="syntax-all syntax-comment">;; Initialize database</span>
(<span class="syntax-all syntax-keyword">def</span> <span class="syntax-all syntax-entity">config</span> {<span class="syntax-all syntax-constant">:store</span>                <span class="syntax-all syntax-constant">:database</span>
             <span class="syntax-all syntax-constant">:migration-dir</span>        <span class="syntax-all syntax-string">&quot;resources/migrations/&quot;</span>
             <span class="syntax-all syntax-constant">:init-script</span>          <span class="syntax-all syntax-string">&quot;schema.sql&quot;</span>
             <span class="syntax-all syntax-constant">:migration-table-name</span> <span class="syntax-all syntax-string">&quot;booky&quot;</span>
             <span class="syntax-all syntax-constant">:db</span> {<span class="syntax-all syntax-constant">:port</span>       <span class="syntax-all syntax-constant">5432</span>
                  <span class="syntax-all syntax-constant">:dbname</span>     <span class="syntax-all syntax-string">&quot;booky&quot;</span>
                  <span class="syntax-all syntax-constant">:host</span>       <span class="syntax-all syntax-string">&quot;localhost&quot;</span>
                  <span class="syntax-all syntax-constant">:dbtype</span>     <span class="syntax-all syntax-string">&quot;postgresql&quot;</span>
                  <span class="syntax-all syntax-constant">:user</span>       <span class="syntax-all syntax-string">&quot;booker&quot;</span>
                  <span class="syntax-all syntax-constant">:password</span>   <span class="syntax-all syntax-string">&quot;dev&quot;</span>}})

<span class="syntax-all syntax-comment">;initialize the database using the &#39;schema.sql&#39; script</span>
(<span class="syntax-all syntax-entity">migratus/init</span> config)</code></pre>

<ol>
	<li>import <code>migratus</code> library</li>
	<li>Config

		<ul>
			<li>Create dir <code>resources/migrations</code> and sql file <code>init.sql</code> with SQL schema mentioned above</li>
		</ul></li>
	<li><code>init</code> function performs database initialization through provided configuration</li>
</ol>

<h3>Datomic </h3>

<p>In this case things a little different as Datomic relies on other different types of storage for persistence. In our case, we’ll be using in memory for the demonstration purposes.<sup><a id="ffn1" href="#fn1" class="footnote">1</a></sup></p>

<h4>Dependency</h4>

<pre><code class="code-highlighted code-clojure">com.datomic/peer {<span class="syntax-all syntax-constant">:mvn/version</span> <span class="syntax-all syntax-string">&quot;1.0.6735&quot;</span>}</code></pre>

<h4>Code</h4>

<p><code>datomic.clj</code></p>

<pre><code class="code-highlighted code-clojure">(<span class="syntax-all syntax-keyword">ns</span> <span class="syntax-all syntax-entity">gig.datomic</span>
  (<span class="syntax-all syntax-constant">:require</span> [datomic.api <span class="syntax-all syntax-constant">:as</span> d]))

(<span class="syntax-all syntax-keyword">def</span> <span class="syntax-all syntax-entity">db-uri</span> <span class="syntax-all syntax-string">&quot;datomic:mem://booky&quot;</span>)

(<span class="syntax-all syntax-entity">d/create-database</span> db-uri)

(<span class="syntax-all syntax-keyword">def</span> <span class="syntax-all syntax-entity">conn</span> (<span class="syntax-all syntax-entity">d/connect</span> db-uri))

(<span class="syntax-all syntax-keyword">def</span> <span class="syntax-all syntax-entity">schema</span> (<span class="syntax-all syntax-entity">edn/read-string</span> (<span class="syntax-all syntax-entity">slurp</span> <span class="syntax-all syntax-string">&quot;resources/schema.edn&quot;</span>)))

@(<span class="syntax-all syntax-entity">d/transact</span> conn schema)</code></pre>

<ul>
	<li>To avoid polluting namespace, I’d rather keep schema into a separate file - <code>resources/schema.edn</code> </li>
	<li><code>d/transact</code> submits transaction to the database</li>
</ul>

<h2>Save data into database </h2>

<h3>SQL</h3>

<h4>Sample data</h4>

<pre><code class="code-highlighted code-clojure">(<span class="syntax-all syntax-keyword">def</span> <span class="syntax-all syntax-entity">book</span>
  {<span class="syntax-all syntax-constant">:title</span> <span class="syntax-all syntax-string">&quot;The Man Without Qualities&quot;</span>
   <span class="syntax-all syntax-constant">:author</span> <span class="syntax-all syntax-string">&quot;Robert Musil&quot;</span>
   <span class="syntax-all syntax-constant">:genre</span> <span class="syntax-all syntax-string">&quot;Philosophical Fiction&quot;</span>
   <span class="syntax-all syntax-constant">:publication-date</span> (<span class="syntax-all syntax-entity">t/date</span> <span class="syntax-all syntax-string">&quot;1943-11-06&quot;</span>)})

(<span class="syntax-all syntax-keyword">def</span> <span class="syntax-all syntax-entity">patron</span>
  {<span class="syntax-all syntax-constant">:first-name</span> <span class="syntax-all syntax-string">&quot;Ulrich&quot;</span>
   <span class="syntax-all syntax-constant">:last-name</span> <span class="syntax-all syntax-string">&quot;&quot;</span>
   <span class="syntax-all syntax-constant">:email</span> <span class="syntax-all syntax-string">&quot;ulrich@kakania.at&quot;</span>})

(<span class="syntax-all syntax-keyword">def</span> <span class="syntax-all syntax-entity">borrower</span>
  {<span class="syntax-all syntax-constant">:first-name</span> <span class="syntax-all syntax-string">&quot;Agatha&quot;</span>
   <span class="syntax-all syntax-constant">:last-name</span> <span class="syntax-all syntax-string">&quot;&quot;</span>
   <span class="syntax-all syntax-constant">:email</span> <span class="syntax-all syntax-string">&quot;agatha@kakania.at&quot;</span>})

(<span class="syntax-all syntax-keyword">def</span> <span class="syntax-all syntax-entity">registry</span>
  {<span class="syntax-all syntax-constant">:book-id</span> <span class="syntax-all syntax-constant">1</span>
   <span class="syntax-all syntax-constant">:patron-id</span> <span class="syntax-all syntax-constant">2</span>
   <span class="syntax-all syntax-constant">:borrower-id</span> <span class="syntax-all syntax-constant">3</span>
   <span class="syntax-all syntax-constant">:borrow-date</span> (<span class="syntax-all syntax-entity">t/date</span> <span class="syntax-all syntax-string">&quot;2023-07-28&quot;</span>)
   <span class="syntax-all syntax-constant">:due-date</span> (<span class="syntax-all syntax-entity">t/date</span> <span class="syntax-all syntax-string">&quot;2023-10-28&quot;</span>)})</code></pre>

<h4>Create a connection to database</h4>

<pre><code class="code-highlighted code-clojure">(<span class="syntax-all syntax-keyword">def</span> <span class="syntax-all syntax-entity">db</span> (<span class="syntax-all syntax-entity">jdbc/get-connection</span> (<span class="syntax-all syntax-constant">:db</span> config)))</code></pre>

<h4>Save</h4>

<pre><code class="code-highlighted code-clojure">(<span class="syntax-all syntax-entity">jdbc/execute!</span>
 db
 (<span class="syntax-all syntax-entity">sql/format</span>
  {<span class="syntax-all syntax-constant">:insert-into</span> <span class="syntax-all syntax-constant">:book</span>
   <span class="syntax-all syntax-constant">:values</span> [book]})
 {<span class="syntax-all syntax-constant">:return-keys</span> <span class="syntax-all syntax-constant">true</span>})</code></pre>

<ol>
	<li><code>jdbc/execut!</code> takes in datasource and query, performs execution and returns the result</li>
	<li><code>sql/format</code> is responsible for processing Clojure map into <code>SQL</code> query</li>
	<li>The map is the example of HoneySQL map syntax</li>
	<li>An option to return inserted data</li>
</ol>

<p>The result</p>

<pre><code class="code-highlighted code-clojure">[#:book{<span class="syntax-all syntax-constant">:id</span> <span class="syntax-all syntax-constant">14</span>,
        <span class="syntax-all syntax-constant">:title</span> <span class="syntax-all syntax-string">&quot;The Man Without Qualities&quot;</span>,
        <span class="syntax-all syntax-constant">:author</span> <span class="syntax-all syntax-string">&quot;Robert Musil&quot;</span>,
        <span class="syntax-all syntax-constant">:genre</span> <span class="syntax-all syntax-string">&quot;Philosophical Fiction&quot;</span>,
        <span class="syntax-all syntax-constant">:publication_date</span> #inst <span class="syntax-all syntax-string">&quot;1943-11-05T23:00:00.000-00:00&quot;</span>}]</code></pre>

<h4><code>sql/format</code> and <code>honeysql</code></h4>

<p>The query above results in:</p>

<pre><code class="code-highlighted code-clojure">[<span class="syntax-all syntax-string">&quot;INSERT INTO book (title, author, genre, publication_date) VALUES (?, ?, ?, ?)&quot;</span>
 <span class="syntax-all syntax-string">&quot;The Man Without Qualities&quot;</span>
 <span class="syntax-all syntax-string">&quot;Robert Musil&quot;</span>
 <span class="syntax-all syntax-string">&quot;Philosophical Fiction&quot;</span>
 #time/date <span class="syntax-all syntax-string">&quot;1943-11-06&quot;</span>]</code></pre>

<h5>Perform the rest of insertions</h5>

<p>At this point I’d rather compose a handy function for execution</p>

<pre><code class="code-highlighted code-clojure">(<span class="syntax-all syntax-keyword">defn</span> <span class="syntax-all syntax-entity">execute</span> [q]
  (<span class="syntax-all syntax-entity">jdbc/execute!</span> db (<span class="syntax-all syntax-entity">sql/format</span> q)
                  {<span class="syntax-all syntax-constant">:return-keys</span> <span class="syntax-all syntax-constant">true</span>}))</code></pre>

<p>Hence insertion of remaining data is simplified</p>

<pre><code class="code-highlighted code-clojure">(<span class="syntax-all syntax-entity">execute</span>
 {<span class="syntax-all syntax-constant">:insert-into</span> <span class="syntax-all syntax-constant">:person</span>
  <span class="syntax-all syntax-constant">:values</span> [patron
           borrower]})

(<span class="syntax-all syntax-entity">execute</span>
 {<span class="syntax-all syntax-constant">:insert-into</span> <span class="syntax-all syntax-constant">:registry</span>
  <span class="syntax-all syntax-constant">:values</span> [registry]})</code></pre>

<h3>Datomic</h3>

<h4>Sample data</h4>

<p>In case of Datomic, sample data looks a bit different, instead of separate definitions, we have all data in a single var:</p>

<pre><code class="code-highlighted code-clojure">(<span class="syntax-all syntax-keyword">def</span> <span class="syntax-all syntax-entity">data</span>
  [{<span class="syntax-all syntax-constant">:db/id</span> <span class="syntax-all syntax-string">&quot;musil&quot;</span>
    <span class="syntax-all syntax-constant">:book/title</span> <span class="syntax-all syntax-string">&quot;The Man Without Qualities&quot;</span>
    <span class="syntax-all syntax-constant">:book/author</span> <span class="syntax-all syntax-string">&quot;Robert Musil&quot;</span>
    <span class="syntax-all syntax-constant">:book/genre</span> <span class="syntax-all syntax-string">&quot;Philosophical Fiction&quot;</span>
    <span class="syntax-all syntax-constant">:book/publication-date</span> (<span class="syntax-all syntax-entity">instant/read-instant-date</span> <span class="syntax-all syntax-string">&quot;1943-11-06&quot;</span>)}

   {<span class="syntax-all syntax-constant">:db/id</span> <span class="syntax-all syntax-string">&quot;ulrich&quot;</span>
    <span class="syntax-all syntax-constant">:person/first-name</span> <span class="syntax-all syntax-string">&quot;Ulrich&quot;</span>
    <span class="syntax-all syntax-constant">:person/last-name</span> <span class="syntax-all syntax-string">&quot;&quot;</span>
    <span class="syntax-all syntax-constant">:person/email</span> <span class="syntax-all syntax-string">&quot;ulrich@kakania.at&quot;</span>}

   {<span class="syntax-all syntax-constant">:db/id</span> <span class="syntax-all syntax-string">&quot;agatha&quot;</span>
    <span class="syntax-all syntax-constant">:person/first-name</span> <span class="syntax-all syntax-string">&quot;Agatha&quot;</span>
    <span class="syntax-all syntax-constant">:person/last-name</span> <span class="syntax-all syntax-string">&quot;&quot;</span>
    <span class="syntax-all syntax-constant">:person/email</span> <span class="syntax-all syntax-string">&quot;agatha@kakania.at&quot;</span>}

   {<span class="syntax-all syntax-constant">:registry/book</span> <span class="syntax-all syntax-string">&quot;musil&quot;</span>
    <span class="syntax-all syntax-constant">:registry/patron</span> <span class="syntax-all syntax-string">&quot;ulrich&quot;</span>
    <span class="syntax-all syntax-constant">:registry/borrower</span> <span class="syntax-all syntax-string">&quot;agatha&quot;</span>
    <span class="syntax-all syntax-constant">:registry/borrow-date</span> (<span class="syntax-all syntax-entity">instant/read-instant-date</span> <span class="syntax-all syntax-string">&quot;2023-07-28&quot;</span>)
    <span class="syntax-all syntax-constant">:registry/due-date</span> (<span class="syntax-all syntax-entity">instant/read-instant-date</span> <span class="syntax-all syntax-string">&quot;2023-10-28&quot;</span>)}])</code></pre>

<h4>Save (transact)</h4>

<pre><code class="code-highlighted code-clojure">(<span class="syntax-all syntax-entity">d/transact</span> conn data)</code></pre>

<ul>
	<li><code>:db/id</code> is a temporary id used in the context of transaction to actually create a relationship. Example from the execution <code>{&quot;musil&quot; 17592186045418,   &quot;ulrich&quot; 17592186045419,  &quot;agatha&quot; 17592186045420}</code></li>
	<li><em>Hence we don’t explicitly force relationship on the schema level, but during transaction</em>. If we try to transact without <code>temporary id</code> the REPL will greet we with error - <code>:db.error/tempid-not-an-entity tempid &#39;whatever&#39; used only as value in transaction</code></li>
</ul>

<h2>Querying data from database</h2>

<p>I wouldn’t say that we’ve been sailing into much familiar waters until now, but at this point things do actually get quite different, challenging at some extent, but I do usually hold myself from jumping to conclusions till the moment I comprehend the technology and reasoning behind design decisions. Down the down you’ll see what I mean.</p>

<h3>Querying through (Honey)SQL</h3>

<p>Run a simple query first, fetch all data from <code>person</code> table</p>

<pre><code class="code-highlighted code-clojure">(<span class="syntax-all syntax-entity">execute</span>
 {<span class="syntax-all syntax-constant">:select</span> [<span class="syntax-all syntax-constant">:*</span>]
  <span class="syntax-all syntax-constant">:from</span> <span class="syntax-all syntax-constant">:person</span>})</code></pre>

<p>The result:</p>

<pre><code class="code-highlighted code-clojure">[#:person{<span class="syntax-all syntax-constant">:id</span> <span class="syntax-all syntax-constant">1</span>,
          <span class="syntax-all syntax-constant">:first_name</span> <span class="syntax-all syntax-string">&quot;Ulrich&quot;</span>,
          <span class="syntax-all syntax-constant">:last_name</span> <span class="syntax-all syntax-string">&quot;&quot;</span>,
          <span class="syntax-all syntax-constant">:email</span> <span class="syntax-all syntax-string">&quot;ulrich@kakania.at&quot;</span>}
 #:person{<span class="syntax-all syntax-constant">:id</span> <span class="syntax-all syntax-constant">2</span>,
          <span class="syntax-all syntax-constant">:first_name</span> <span class="syntax-all syntax-string">&quot;Agatha&quot;</span>,
          <span class="syntax-all syntax-constant">:last_name</span> <span class="syntax-all syntax-string">&quot;&quot;</span>,
          <span class="syntax-all syntax-constant">:email</span> <span class="syntax-all syntax-string">&quot;agatha@kakania.at&quot;</span>}]</code></pre>

<h4>Borrower Agatha</h4>

<p>Now, let’s make things a little complicated and fetch books from registry where the borrower is <code>Agatha</code>.<sup><a id="ffn2" href="#fn2" class="footnote">2</a></sup></p>

<p>A regular SQL:</p>

<pre><code class="code-highlighted code-sql"><span class="syntax-all syntax-keyword">SELECT</span> <span class="syntax-all syntax-constant">book</span>.<span class="syntax-all syntax-constant">title</span>, 
       <span class="syntax-all syntax-constant">registry</span>.<span class="syntax-all syntax-constant">borrow_date</span>,
       <span class="syntax-all syntax-constant">borrower</span>.<span class="syntax-all syntax-constant">first_name</span> <span class="syntax-all syntax-keyword">AS</span> borrower,
       <span class="syntax-all syntax-constant">patron</span>.<span class="syntax-all syntax-constant">first_name</span> <span class="syntax-all syntax-keyword">AS</span> patron
<span class="syntax-all syntax-keyword">FROM</span> registry
         <span class="syntax-all syntax-keyword">INNER JOIN</span> book <span class="syntax-all syntax-keyword">ON</span> <span class="syntax-all syntax-constant">registry</span>.<span class="syntax-all syntax-constant">book_id</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">book</span>.<span class="syntax-all syntax-constant">id</span>
         <span class="syntax-all syntax-keyword">INNER JOIN</span> person <span class="syntax-all syntax-keyword">AS</span> borrower <span class="syntax-all syntax-keyword">ON</span> <span class="syntax-all syntax-constant">registry</span>.<span class="syntax-all syntax-constant">borrower_id</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">borrower</span>.<span class="syntax-all syntax-constant">id</span>
         <span class="syntax-all syntax-keyword">INNER JOIN</span> person <span class="syntax-all syntax-keyword">AS</span> patron <span class="syntax-all syntax-keyword">ON</span> <span class="syntax-all syntax-constant">registry</span>.<span class="syntax-all syntax-constant">patron_id</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">patron</span>.<span class="syntax-all syntax-constant">id</span>
<span class="syntax-all syntax-keyword">WHERE</span> <span class="syntax-all syntax-constant">borrower</span>.<span class="syntax-all syntax-constant">email</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&#39;agatha@kakania.at&#39;</span>;</code></pre>

<p>HoneySQL:</p>

<pre><code class="code-highlighted code-clojure">(<span class="syntax-all syntax-entity">execute</span>
 {<span class="syntax-all syntax-constant">:select</span> [<span class="syntax-all syntax-constant">:book.title</span>
           <span class="syntax-all syntax-constant">:registry.borrow-date</span>
           [<span class="syntax-all syntax-constant">:borrower.first-name</span> <span class="syntax-all syntax-constant">:borrower</span>]
           [<span class="syntax-all syntax-constant">:patron.first-name</span> <span class="syntax-all syntax-constant">:patron</span>]]
  <span class="syntax-all syntax-constant">:from</span> [<span class="syntax-all syntax-constant">:registry</span>]
  <span class="syntax-all syntax-constant">:join</span> [<span class="syntax-all syntax-constant">:book</span> [<span class="syntax-all syntax-constant">:=</span> <span class="syntax-all syntax-constant">:registry.book-id</span> <span class="syntax-all syntax-constant">:book.id</span>]
        [<span class="syntax-all syntax-constant">:person</span> <span class="syntax-all syntax-constant">:borrower</span>] [<span class="syntax-all syntax-constant">:=</span> <span class="syntax-all syntax-constant">:registry.borrower-id</span> <span class="syntax-all syntax-constant">:borrower.id</span>]
        [<span class="syntax-all syntax-constant">:person</span> <span class="syntax-all syntax-constant">:patron</span>] [<span class="syntax-all syntax-constant">:=</span> <span class="syntax-all syntax-constant">:registry.patron-id</span> <span class="syntax-all syntax-constant">:patron.id</span>]]
  <span class="syntax-all syntax-constant">:where</span> [<span class="syntax-all syntax-constant">:=</span> <span class="syntax-all syntax-constant">:borrower.email</span> <span class="syntax-all syntax-string">&quot;agatha@kakania.at&quot;</span>]})</code></pre>

<p>Result:</p>

<pre><code class="code-highlighted code-clojure">[{<span class="syntax-all syntax-constant">:book/title</span> = <span class="syntax-all syntax-string">&quot;The Man Without Qualities&quot;</span>
  <span class="syntax-all syntax-constant">:registry/borrow_date</span> = <span class="syntax-all syntax-constant">2023-07-28</span>
  <span class="syntax-all syntax-constant">:person/borrower</span> = <span class="syntax-all syntax-string">&quot;Agatha&quot;</span>
  <span class="syntax-all syntax-constant">:person/patron</span> = <span class="syntax-all syntax-string">&quot;Ulrich&quot;</span>}]</code></pre>

<figure><img src="SQL.gif"/></figure>

<h3>Querying through Datalog (Datomic)</h3>

<p>Datalog is the querying language supported here, nonetheless Datomic provides 3 ways of pulling data:</p>

<ol>
	<li><code>Pull API</code>: The pull API in Datomic is a powerful, declarative way to retrieve an entity and its associated attributes in one call, letting us shape the returned data to fit our needs.<br/></li>
	<li><code>Datalog Queries</code>: Datomic uses Datalog, a declarative logic programming language, enabling expressive relational queries including joins, recursion, negation, and more, where we specify a pattern to match in the database and get back a set of tuples matching the pattern.<br/></li>
	<li><code>Entity API</code>: The Entity API in Datomic is a simpler method to access the attributes of a single entity given its entity ID, offering a less flexible but straightforward alternative to the Pull API for accessing multiple attributes of a single entity.</li>
</ol>

<h4>A regular Datalog query</h4>

<p>The first and utmost important step is to capture the current state of the database in Clojure, the usual step is:</p>

<pre><code class="code-highlighted code-clojure">(<span class="syntax-all syntax-keyword">def</span> <span class="syntax-all syntax-entity">db</span> (<span class="syntax-all syntax-entity">d/db</span> conn))</code></pre>

<p>The d/db function is used to get a value of the database from the connection. The value represents the entire database at a specific point in time.</p>

<p>Then we can perform queries:</p>

<pre><code class="code-highlighted code-clojure">(<span class="syntax-all syntax-entity">d/q</span> &#39;[<span class="syntax-all syntax-constant">:find</span> ?e ?first-name ?email
       <span class="syntax-all syntax-constant">:where</span>
       [?e <span class="syntax-all syntax-constant">:person/first-name</span> ?first-name]
       [?e <span class="syntax-all syntax-constant">:person/email</span> ?email]]
     db)</code></pre>

<ul>
	<li><code>q/q</code> is a query execution function</li>
	<li><code>:find</code> receives one or more attributes, SQL analog is <code>SELECT</code></li>
	<li><code>:where</code> is core of the query

		<ul>
			<li><code>?e</code> is a variable that will hold the entity ID. In Datalog, variables are represented by symbols that start with a <code>?</code></li>
			<li><code>:person/first-name</code> is an attribute in the database. In this case, it represents the first name of a person</li>
			<li><code>?first-name</code> is another variable that will hold the value of the <code>:person/first-name</code> attribute for the entity <code>?e</code> in the following queries if we need to narrow it down.</li>
		</ul>

		<p>The clause <code>[?e :person/first-name ?first-name] </code> can be read as <em>for the entity <code>?e</code>, find the value of the <code>:person/first-name</code> attribute and bind it to the <code>?first-name</code> variable</em>. <br/><br/>In more simple terms: <em>Find me the first name of a person, and let&#39;s refer to this person as <code>?e</code> and their first name as <code>?first-name</code>.</em></p></li>
</ul>

<p>Result:</p>

<pre><code class="code-highlighted code-clojure">#{[<span class="syntax-all syntax-constant">17592186045421</span> <span class="syntax-all syntax-string">&quot;Agatha&quot;</span> <span class="syntax-all syntax-string">&quot;&quot;</span> <span class="syntax-all syntax-string">&quot;agatha@kakania.at&quot;</span>]
  [<span class="syntax-all syntax-constant">17592186045420</span> <span class="syntax-all syntax-string">&quot;Ulrich&quot;</span> <span class="syntax-all syntax-string">&quot;&quot;</span> <span class="syntax-all syntax-string">&quot;ulrich@kakania.at&quot;</span>]}</code></pre>

<p>A regular Datalog query returns <em>a set of tuples</em> without corresponding keys. If we need to return maps, then <code>:keys</code> is require alongside corresponding arguments:</p>

<pre><code class="code-highlighted code-clojure">(<span class="syntax-all syntax-entity">d/q</span> &#39;[<span class="syntax-all syntax-constant">:find</span> ?e ?first-name ?last-name ?email
       <span class="syntax-all syntax-constant">:keys</span> id first-name last-name email
       <span class="syntax-all syntax-constant">:where</span>
       [?e <span class="syntax-all syntax-constant">:person/first-name</span> ?first-name]
       [?e <span class="syntax-all syntax-constant">:person/last-name</span> ?last-name]
       [?e <span class="syntax-all syntax-constant">:person/email</span> ?email]]
     db)</code></pre>

<p>Result</p>

<pre><code class="code-highlighted code-clojure">[{<span class="syntax-all syntax-constant">:id</span> <span class="syntax-all syntax-constant">17592186045421</span>,
  <span class="syntax-all syntax-constant">:first-name</span> <span class="syntax-all syntax-string">&quot;Agatha&quot;</span>,
  <span class="syntax-all syntax-constant">:last-name</span> <span class="syntax-all syntax-string">&quot;&quot;</span>,
  <span class="syntax-all syntax-constant">:email</span> <span class="syntax-all syntax-string">&quot;agatha@kakania.at&quot;</span>}
 {<span class="syntax-all syntax-constant">:id</span> <span class="syntax-all syntax-constant">17592186045420</span>,
  <span class="syntax-all syntax-constant">:first-name</span> <span class="syntax-all syntax-string">&quot;Ulrich&quot;</span>,
  <span class="syntax-all syntax-constant">:last-name</span> <span class="syntax-all syntax-string">&quot;&quot;</span>,
  <span class="syntax-all syntax-constant">:email</span> <span class="syntax-all syntax-string">&quot;ulrich@kakania.at&quot;</span>}]</code></pre>

<h4>Pull API</h4>

<pre><code class="code-highlighted code-clojure">(<span class="syntax-all syntax-entity">d/q</span> &#39;[<span class="syntax-all syntax-constant">:find</span> [(<span class="syntax-all syntax-entity">pull</span> ?e [*]) ...]
       <span class="syntax-all syntax-constant">:where</span> [?e <span class="syntax-all syntax-constant">:person/first-name</span>]]
     db))</code></pre>

<ul>
	<li><code>pull</code> is a function provided by Datomic that retrieves entities from the database along with their attributes.</li>
	<li><code>?e</code> is a variable that represents an entity ID. This variable should have been bound to a value in a previous clause of the query.</li>
	<li><code>[*]</code> is a pull pattern that specifies which attributes to retrieve. The asterisk (<code>*</code>) is a wildcard that means <em>all attributes</em>. <code>SQL</code> equivalent is SELECT *</li>
</ul>

<p>So, <code>(pull ?e [*])</code> can be read as <em>retrieve the entity with the ID <code>?e</code> and all of its attributes</em>. </p>

<p>In simple terms, it&#39;s like asking the database: <em>Give me everything you know about the entity identified by <code>?e</code></em>.</p>

<p>Result:</p>

<pre><code class="code-highlighted code-clojure">[{<span class="syntax-all syntax-constant">:db/id</span> <span class="syntax-all syntax-constant">17592186045420</span>,
  <span class="syntax-all syntax-constant">:person/first-name</span> <span class="syntax-all syntax-string">&quot;Ulrich&quot;</span>,
  <span class="syntax-all syntax-constant">:person/last-name</span> <span class="syntax-all syntax-string">&quot;&quot;</span>,
  <span class="syntax-all syntax-constant">:person/email</span> <span class="syntax-all syntax-string">&quot;ulrich@kakania.at&quot;</span>}
 {<span class="syntax-all syntax-constant">:db/id</span> <span class="syntax-all syntax-constant">17592186045421</span>,
  <span class="syntax-all syntax-constant">:person/first-name</span> <span class="syntax-all syntax-string">&quot;Agatha&quot;</span>,
  <span class="syntax-all syntax-constant">:person/last-name</span> <span class="syntax-all syntax-string">&quot;&quot;</span>,
  <span class="syntax-all syntax-constant">:person/email</span> <span class="syntax-all syntax-string">&quot;agatha@kakania.at&quot;</span>}]</code></pre>

<h4>Entity API</h4>

<pre><code class="code-highlighted code-clojure">(<span class="syntax-all syntax-entity">d/entity</span> db entity-id)</code></pre>

<ul>
	<li><code>d/entity</code> is a function provided by Datomic that retrieves an entity from the database. It returns an entity map, which is a lazy, dynamic view of the entity&#39;s attributes at the point in time represented by the database value.</li>
	<li><code>db</code> <em>let’s repeat</em> - <code>db</code> is the Datomic database value, representing a particular point in time in the database.</li>
	<li><code>entity-id</code> is the unique identifier of the entity that we want to retrieve. This identifier is typically a number that Datomic automatically assigns when the <code>entity</code> is first created, but it can also be a <code>lookup ref</code> or a <code>tempid</code>, depending on the context.</li>
</ul>

<p> <code>(d/entity db entity-id)</code> can be read as <em>retrieve the entity with the ID <code>entity-id</code> from the database <code>db</code></em>.</p>

<p>In simple terms - <em>Give me the thing (entity) identified by <code>entity-id</code>, as it was at the point in time represented by <code>db</code></em>.</p>

<pre><code class="code-highlighted code-clojure">(<span class="syntax-all syntax-keyword">let</span> [entity (<span class="syntax-all syntax-entity">d/entity</span> db <span class="syntax-all syntax-constant">17592186045420</span>)]
  (<span class="syntax-all syntax-entity">select-keys</span> entity [<span class="syntax-all syntax-constant">:person/first-name</span>
                       <span class="syntax-all syntax-constant">:person/last-name</span>
                       <span class="syntax-all syntax-constant">:person/email</span>]))</code></pre>

<p>Result:</p>

<pre><code class="code-highlighted code-clojure">#:person{<span class="syntax-all syntax-constant">:first-name</span> <span class="syntax-all syntax-string">&quot;Ulrich&quot;</span>,
         <span class="syntax-all syntax-constant">:last-name</span> <span class="syntax-all syntax-string">&quot;&quot;</span>,
         <span class="syntax-all syntax-constant">:email</span> <span class="syntax-all syntax-string">&quot;ulrich@kakania.at&quot;</span>}</code></pre>

<p>In the context of the real-world application we usually hold the id and Entity API is certainly a unique and beneficial feature, particularly in the scenarios where the performance is critical.</p>

<h4>Borrower - Agatha </h4>

<p>We had the first glance at Datomic query engine and it’s variations, at this point we’re ready to compose a bit more complex query and fetch registry record that corresponds <code>agatha</code> as the borrower.</p>

<pre><code class="code-highlighted code-clojure">(<span class="syntax-all syntax-entity">d/q</span> &#39;[<span class="syntax-all syntax-constant">:find</span> ?title ?borrow-date ?borrower-name ?patron-name
       <span class="syntax-all syntax-constant">:keys</span> title borrow-date borrower patron
       <span class="syntax-all syntax-constant">:where</span>
       [?registry <span class="syntax-all syntax-constant">:registry/book</span> ?book]
       [?registry <span class="syntax-all syntax-constant">:registry/borrow-date</span> ?borrow-date]
       [?registry <span class="syntax-all syntax-constant">:registry/borrower</span> ?borrower]
       [?registry <span class="syntax-all syntax-constant">:registry/patron</span> ?patron]
       [?book <span class="syntax-all syntax-constant">:book/title</span> ?title]
       [?borrower <span class="syntax-all syntax-constant">:person/first-name</span> ?borrower-name]
       [?borrower <span class="syntax-all syntax-constant">:person/email</span> <span class="syntax-all syntax-string">&quot;agatha@kakania.at&quot;</span>]
       [?patron <span class="syntax-all syntax-constant">:person/first-name</span> ?patron-name]]
     db)</code></pre>

<ol>
	<li> The first 4 clauses, regarding <code>:registry</code> identify an entry - the associated <code>book</code>, the <code>borrow date</code>, and both the <code>borrower</code> and <code>patron</code> involved</li>
	<li><code>[?book :book/title ?title]</code> retrieves the title of the associated book</li>
	<li><code>[?borrower :person/first-name ?borrower-name]</code> finds the first name of the borrower</li>
	<li><code>[?borrower :person/email &quot;agatha@kakania.at&quot;]</code> ensures that the borrower&#39;s email is <code>agatha@kakania.at</code></li>
	<li><code>[?patron :person/first-name ?patron-name]</code>: Retrieves the first name of the patron</li>
</ol>

<p><code>:find</code> is complemented with a list of data variables we are interested in.</p>

<p>Result:</p>

<pre><code class="code-highlighted code-clojure">[{<span class="syntax-all syntax-constant">:title</span> <span class="syntax-all syntax-string">&quot;The Man Without Qualities&quot;</span>,
  <span class="syntax-all syntax-constant">:borrow-date</span> #inst <span class="syntax-all syntax-string">&quot;2023-07-28T00:00:00.000-00:00&quot;</span>,
  <span class="syntax-all syntax-constant">:borrower</span> <span class="syntax-all syntax-string">&quot;Agatha&quot;</span>,
  <span class="syntax-all syntax-constant">:patron</span> <span class="syntax-all syntax-string">&quot;Ulrich&quot;</span>}]</code></pre>

<figure><img src="Datomic.gif"/></figure>

<p>— </p>

<p>At this in time and space, our little journey has come to an end. In the next article we’ll talk about Datomic Specific features, that would improve the processes we have talked about.</p>

<ol id="footnotes">
	<li id="fn1">I know it’s not exactly the same, but I’d like to show that up and running Datomic in development mode is a simple as it possibly get. <a href="#ffn1">&#x21A9;&#xFE0E;</a></li>
	<li id="fn2">Surely in a real-world scenario, where clause would be looked up by id, for the illustrative purposes, let’s use email. <a href="#ffn2">&#x21A9;&#xFE0E;</a></li>
</ol></body>
</html>

